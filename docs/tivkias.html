<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Exam6 - Технологии информационного взаимодействия компонент информационно-аналитических систем</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Exam6</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./tivkias.html" rel="" target="" aria-current="page">
 <span class="menu-text">Технологии информационного взаимодействия компонент информационно-аналитических систем</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./saznsd.html" rel="" target="">
 <span class="menu-text">Системы аутентификации и защита информации от несанкционированного доступа</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./uuibias.html" rel="" target="">
 <span class="menu-text">Угрозы и уязвимости ИБ ИАС</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Технологии информационного взаимодействия компонент информационно-аналитических систем</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p><strong>1. Компилятор.</strong></p>
<p>Компилятор — программа, переводящая написанный на языке программирования текст в набор машинных кодов. В основном используется для программ, которые переводят исходный код с ЯП высокого уровня на более низкий.</p>
<p><strong>2. Перекодировщик.</strong></p>
<p>Перекодировщик осуществляет перевод текста программы одного ЯП в текст программы другого аналогичного по уровню.</p>
<p><strong>3. Компилирующий режим.</strong></p>
<p>Компиляция — это процесс перевода исходного кода программы на машинный язык. Ее результатом является создание исполняемого файла программы, который может быть запущен в торговой платформе.</p>
<p>Компиляция состоит из нескольких этапов:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Лексический анализ</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Синтаксический анализ</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Семантический анализ</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Генерация кода</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Оптимизация кода</p>
<p><strong>4. Интерпретатор.</strong></p>
<p>Интерпретатор (на входе тексты на языке высокого уровня, на выходе тоже машинный код (который на выход подает текст по частям))</p>
<p>Интерпретация — построчный анализ, обработка и выполнение исходного кода программы или запроса (в отличие от компиляции, где весь текст программы, перед запуском, анализируется и транслируется в машинный или байт-код, без её выполнения)</p>
<p><strong>5. Основные части транслятора.</strong></p>
<p>Транслятор — программа, которая принимает на вход текст программы на одном языке (он в этом случае называется исходный язык), и преобразует её в программу, написанную на другом языке. Перевод одного языка в другой называется трансляцией.</p>
<p>Виды трансляторов:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Компилятор</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Интерпретатор</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ретранслятор</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Перекодировщик</p>
<p>Транслятор можно построить по классической схеме, в которой чётко выделяются 3 части: лексический анализатор, распознаватель (синтаксический анализатор) и генератор (семантический анализатор);</p>
<p><img src="images/5kor.png" class="img-fluid"></p>
<p><strong>6. Анализирующая часть транслятора состоит из . . .</strong></p>
<p>Лексического, синтаксического и семантическогоанализаторов.</p>
<p><strong>Лексический анализатор</strong> преобразует входной символьный поток в последовательность более крупных единиц – лексем. Например, текст из 14 символов (включая пробелы) преобразуется в последовательность из 7 лексем</p>
<p><strong>Синтаксический анализатор</strong> входного языка проверяет синтаксическую правильность входной цепочки (уже разбитой на лексемы) и строит её семантическое дерево.</p>
<p><strong>Контекстный анализатор</strong> проверяет выполнение контекстных условий (соответствия типов данных, числа параметров процедур, отсутствия передачи управления внутрь тела цикла и многих других), а также расширяет семантическое дерево программы до её полной семантической структуры. На практике его обычно соединяют с синтаксическим анализатором.</p>
<p><strong>Семантический анализатор</strong> – это часть компилятора, которая проверяет смысловую правильность конструкции языка. Задача семантического анализатора состоит в том, чтобы извлечь из формально построенного синтаксического дерева содержательную информацию о структуре программы.</p>
<p><strong>7. Последовательность работы анализаторов.</strong></p>
<p>Возможны 2 схемы работы транслятора.</p>
<p>Первая – использует блочный принцип, при котором части транслятора вызываются в последовательности: <strong>лексический анализатор, распознаватель, генератор</strong>. Каждая часть обрабатывает всю программу от начала до конца и только после этого работает следующая часть.</p>
<p>Вторая – использует принципы подпрограмм, когда все части транслятора работают <strong>совместно</strong>, каждый очередной входной символ лексического анализатора немедленно обрабатывается распознавателем, а каждый элемент разбора, если нужно, тут же вызывает требуемую семантическую подпрограмму генератора.</p>
<p><strong>8. Как реализованы лексический и синтаксический анализаторы в однопроходном трансляторе?</strong></p>
<p>Лексический анализатор и генератор кода выступают в роли вызываемых им подпрограмм. Как только синтаксическому анализатору нужна очередная лексема, он вызывает сканер. При получении фрагмента промежуточного представления осуществляется обращение к генератору кода. Завершение процесса трансляции происходит после получения и обработки последней лексемы и инициируется синтаксическим анализатором.</p>
<p><strong>9. Реализация семантического анализатора.</strong></p>
<p>Семантический анализатор – это часть компилятора, которая проверяет смысловую правильность конструкции языка.</p>
<p>Задача семантического анализатора состоит в том, чтобы извлечь из формально построенного синтаксического дерева содержательную информацию о структуре программы.</p>
<p>Входными данными для семантического анализа служат: таблица идентификаторов; результаты разбора синтаксических конструкций входного языка.</p>
<p>Семантический анализ выполняется на 2 этапах компиляции: на этапе синтаксического разбора и в начале этапа подготовки к генерации кода.</p>
<p><strong>10. Какие типы ошибок должна распознавать анализирующая часть транслятора?</strong></p>
<p>3 вида ошибок:</p>
<p>Лексические ошибки, ошибки набивания текста. Самое простое – ошибки в ключевых словах. Например, в словах: "Begin", "End".</p>
<p>Синтаксические ошибки – ошибки в конструкциях используемого (разрабатываемого) языка программирования. Т.е., входной текст не соответствует правилам написания входного языка.</p>
<p>Семантические ошибки – ошибки в алгоритме программы (не ловятся транслирующими средствами)</p>
<p><strong>11. Какие типы ошибок распознаются в генерирующей части транслятора?</strong></p>
<p>В лексемах отсутствуют комментарии.</p>
<p>Лексемы одинаковой длины.</p>
<p>Лексемы несут числовую информацию.</p>
<p><strong>12. Генерирующая часть транслятора состоит из: …</strong></p>
<p><strong>13. На вход генерирующей части транслятора поступают: …</strong></p>
<p>На входе генератора кода – промежуточные таблицы</p>
<p><strong>14. На выходе генератора кода получаем: …</strong></p>
<p>На выходе – текст на выходном языке.</p>
<p><strong>15. Вход и выход генератора кода (генерирующей части транслятора).</strong></p>
<p>На входе генератора кода – промежуточные таблицы на выходе – текст на выходном языке.</p>
<p><strong>16. Генерирующая часть транслятора в свою очередь состоит из: . . .</strong></p>
<p><strong>17. В какой части транслятора реализован семантический анализатор?</strong></p>
<p>Семантический анализ выполняется на 2 этапах компиляции: на этапе синтаксического разбора и в начале этапа подготовки к генерации кода.</p>
<p>В первом случае всякий раз по завершении распознавания определенной синтаксической конструкции входного языка выполняется её семантическая проверка на основе имеющихся в таблице идентификаторов данных.</p>
<p>Во втором случае, после завершения всей фазы синтаксического разбора, выполняется полный семантический анализ программы на основании данных в таблице идентификаторов.</p>
<p>В каждом компиляторе обычно присутствуют оба варианта семантического анализатора.</p>
<p><strong>18. Что должен демонстрировать транслятор, работающий до первой ошибки?</strong></p>
<p>Диагностические сообщения об ошибке, указание конкретного места и типа ошибки.</p>
<p><strong>19. Основные преимущества работы транслятора до первой ошибки по сравнению с традиционными вариантами.</strong></p>
<p>Традиционный вариант диагностики (все ошибки) имеет существенные недостатки – так называемые наведенные ошибки. Например: при неправильном описании переменной в заголовке программы, все вхождения этой переменной в основной части программы будут диагностироваться ошибочными.</p>
<p>Иногда при изменении, скажем, одного оператора промышленный транслятор выдает целый ряд ошибок и среди них достаточно трудно найти "основную" или "главную".</p>
<p>Алгоритм работы до первой ошибки вполне приемлем при реализации проблемно-ориентированного ЯП. Упор делается на точное диагностирование ошибки.</p>
<p><strong>20. Что означает число проходов (однопроходный транслятор, двухпроходный транслятор, многопроходный транслятор)?</strong></p>
<p>Проход – это полный просмотр исходного текста программы.</p>
<p>Однопроходной транслятор — транслятор, преобразующий исходный код при его однократном последовательном чтении (за один проход).</p>
<p>Многопроходной транслятор — транслятор, преобразующий исходный код после его нескольких чтений (за несколько проходов).</p>
<p><strong>21. Семантические ошибки.</strong></p>
<p>Семантические ошибки – ошибки в алгоритме программы (не ловятся транслирующими средствами).</p>
<p>Семантическая ошибка возникает, когда оператор синтаксически правильный, но не выполняет то, что задумал программист. Иногда это приводит к сбою программы, например, в случае деления на ноль.</p>
<p>В большинстве случаев компилятор не сможет отловить большинство из этих типов проблем, потому что компилятор предназначен для обеспечения соблюдения грамматики, а не намерений.</p>
<p><strong>22. Какие промежуточные этапы необходимо использовать при переходе от «постановки задачи» к «программному обеспечению»?</strong></p>
<p>Переход от «Постановки задачи» к «Программе» труден и неэффективен. Целесообразно добавить еще два элемента «Алгоритм» и «Блок-схема алгоритма».</p>
<p>Основные усилия нужно направить на создание алгоритма (70% всех усилий). Затем по алгоритму построить блок-схему (20 %), которая является графическим образом программы. Переход от блок-схемы к программе должен занимать немного усилий.</p>
<p><strong>23. Основные принципы структурного программирования.</strong></p>
<p>3 принципа:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; максимальное включение комментария в программу,</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; не использование оператора GOTO;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; использование только трех (пяти) разрешенных блоков: функционального, ветвления (If-THEN-ELSE и случай CASE) и цикла (с предусловием и с постусловием)</p>
<p><img src="images/23kor.png" class="img-fluid"></p>
<p><img src="images/23kor_.png" class="img-fluid"></p>
<p><strong>24. Три основных блока структурного программирования: . . .</strong></p>
<p><img src="images/24kor.png" class="img-fluid"></p>
<p><strong>25. Переход от 3 этапов структурного программирования к 5-ти: . . .</strong></p>
<p><img src="images/25kor.png" class="img-fluid"></p>
<p><strong>26. Пять основных блоков структурного программирования включают в себя два блока цикла: . . .</strong></p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; цикл с пред условием</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; цикл с пост условием</p>
<p><strong>27. Основное (объединяющее) достоинство трех блоков структурного программирование.</strong></p>
<p><strong>28. Из трех операторов цикла какой избыточен (без него можно обойтись)?</strong></p>
<p>3 вида конструкций цикла:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; с фиксированным числом итераций,</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; с предусловием,</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; с постусловием.</p>
<p>Избыточный варианта (а). Без варианта (а) можно обойтись</p>
<p><strong>29. Три этапа программирования: . . .</strong></p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Написание программы.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Откладка.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Тестирование</p>
<p><strong>31. Основные составляющие формы Бэкуса-Наура.</strong></p>
<p>БНФ – формальная система описания синтаксиса, в которой одни синтаксические категории последовательно определяются через другие категории. БНФ используется для описания контекстно-свободных формальных грамматик. Используется для описания синтаксиса ЯП, данных, протоколов</p>
<p>язык = "Вegin" Звено...Звено Опр ";" ... Опр "End"</p>
<p>Звено = ["First" ! "Second"] Вещ "," ... Вещ</p>
<p>Опр = &lt;/ Метка":" /&gt; Переменная "=" Цел</p>
<p>Вещ = Цел "." Цел</p>
<p>...</p>
<p>Состовляющие:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; терминалы</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; нетерминалы</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; спец символы</p>
<p>&nbsp;Терминалы – основа создаваемого проблемно-ориентированного ЯП, их выбор (о необходимости отличия терминалов друг от друга, примеры).</p>
<p>&nbsp;Нетерминалы – вспомогательный инструмент формального описания языка (о необходимости также создавать данные элементы максимально отличными друг от друга).</p>
<p>&nbsp;Специальные символы – их соответствие основным инструментам программирования. Методический пример описания проблемно-ориентированного ЯП с помощью БНФ.</p>
<p>Терминалы даются в кавычках. Терминалы неизменны</p>
<p>Описание специальных символов { ... "разд" ... ! [] &lt;/ /&gt;} на данном примере</p>
<p>Нетерминалы могут быть во-первых – любыми. во-вторых, и использовать в разных вариантах</p>
<p>Однозначность БНФ:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Все нетерминалы получаются путем выражения через терминалы.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Все нетерминалы встречаются как слева, так и справа, кроме корней терминала.</p>
<p><strong>32. Терминалы.</strong></p>
<p>Основная составляющая формы Бэкуса-Наура (терминалы, нетерминалы, специальные символы)</p>
<p>БНФ – это то, что мы делали в прошлом семаке</p>
<p>Язык = "Вegin" Звено...Звено Опр ";" ... Опр "End"</p>
<p>Звено = ["First" ! "Second"] Вещ "," ... Вещ</p>
<p>Опр = &lt;/ Метка":" /&gt; Переменная "=" Цел</p>
<p>Особенности:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Терминалы даются в кавычках.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Терминалы неизменны.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Все нетерминаты (путем подстановок) выражаются через терминалы.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Терминалы – слова входного языка.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Терминалы являются основой создаваемого проблемно-ориентированного ЯП</p>
<p><strong>33. Нетерминалы.</strong></p>
<p>Основная составляющая формы Бэкуса-Наура (терминалы, нетерминалы, специальные символы)</p>
<p>БНФ – это то, что мы делали в прошлом семаке</p>
<p>Язык = "Вegin" Звено...Звено Опр ";" ... Опр "End"</p>
<p>Звено = ["First" ! "Second"] Вещ "," ... Вещ</p>
<p>Опр = &lt;/ Метка":" /&gt; Переменная "=" Цел</p>
<p>Особенности:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Нетерминалы – промежуточные слова. Нетерминалы, по сути, вспомогательный инструмент формального описания языка</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Терминалы неизменны, а нетерминалы могут быть любыми и использовать в разных вариантах. Все нетерминаты (путем подстановок) выражаются через терминалы.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Все нетерминалы стоят как слева, так и справа (кроме одного некорневого нетерминала)</p>
<p>1) Опр = &lt;/ Метка ":" /&gt; Переменная "=" Цел</p>
<p>Метка = Цел</p>
<p>2) Опр = &lt;/ Цел ":" /&gt; Переменная "=" Цел</p>
<p><strong>34. Диагностика транслятора осуществляется.</strong></p>
<p>Диагностика транслятора. Основная ценность транслирующего средства – нахождение любой ошибки в тексте на входном языке. Для этого (в качестве "ловушки") используется дерево разбора, благодаря которому исходный текст расчленяется на отдельные составляющие</p>
<p>Диагностика должна:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Адекватное указание ошибки. Диагностические сообщения должны нести в себе конкретный характер</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; В тех случаях, когда существует некоторая неоднозначность (можно указать два или три варианта ошибки), необходимо перечислять все варианты.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Алгоритм работы до первой ошибки вполне приемлем при реализации проблемно-ориентированного ЯП. Упор делается на точное диагностирование ошибки.</p>
<p><strong>35. Лексический анализатор.</strong></p>
<p>Лексический анализ («токенизация») — процесс аналитического разбора входной последовательности символов на распознанные группы — лексемы, с целью получения на выходе идентифицированных последовательностей, называемых «токенами» (подобно группировке букв в словах). В простых случаях понятия «лексема» и «токен» идентичны, но более сложные токенизаторы дополнительно классифицируют лексемы по различным типам («идентификатор, оператор», «часть речи» и т. п.).</p>
<p>Лексический анализ используется в компиляторах и интерпретаторах исходного кода языков программирования, и в различных парсерах слов естественных языков.</p>
<p>Как правило, лексический анализ производится с точки зрения определённого формального языка или набора языков.</p>
<p><strong>36. Вход и выход лексического анализатора.</strong></p>
<p>Лексический анализ («токенизация») — процесс аналитического разбора входной последовательности символов на распознанные группы — лексемы, с целью получения на выходе идентифицированных последовательностей, называемых «токенами» (подобно группировке букв в словах).</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; на входе тексты на исходном проблемно-ориентированном языке</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; на выходе – лексемы</p>
<p>Традиционно принято организовывать процесс лексического анализа, рассматривая входную последовательность символов как поток символов.</p>
<p><strong>37. Основные задачи, решаемые лексическим анализатором.</strong></p>
<p>Лексический анализ («токенизация») — процесс аналитического разбора входной последовательности символов на распознанные группы — лексемы, с целью получения на выходе идентифицированных последовательностей, называемых «токенами»</p>
<p>Входной массив данных имеет смешанную текстово-цифровую информацию. С этим работать трудно. Нужно все привести к какой-либо единой форме. А дальше привести его к цифровому виду.</p>
<p>Таким образом, столь «разношерстную» информацию удается привести к единой цифровой форме, а также все полученные элементы (лексемы) имеют одинаковую длину.</p>
<p>Лексический анализатор – первый проход транслирующего средства по входному тексту. Другими словами, этот анализатор – приведение текста к единому формату, с которых значительно удобнее работать, нежели со входным текстом</p>
<p><strong>38. Лексические ошибки.</strong></p>
<p>Лексический анализ («токенизация») — процесс аналитического разбора входной последовательности символов на распознанные группы — лексемы, с целью получения на выходе идентифицированных последовательностей, называемых «токенами»</p>
<p>В ходе лектического анализа могут находится лексические ошибки. Лексические ошибки – неправильное написание слов. К примеру: система Microsoft Word (подчеркивание красным)</p>
<p>Наиболее распространенные лексические ошибки:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; неправильная буква в слове,</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; отсутствует одна буква,</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; одна лишняя буква,</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; две рядом стоящие буквы переставлены в тексте.</p>
<p><strong>39. Наиболее распространенные виды лексических ошибок (в словах)</strong></p>
<p>Наиболее распространенные лексические ошибки:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; неправильная буква в слове,</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; отсутствует одна буква,</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; одна лишняя буква,</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; две рядом стоящие буквы переставлены в тексте.</p>
<p><strong>40. а) неправильная буква, б) пропущена буква, в) повторена буква, г) лишняя буква, д) две рядом стоящие буквы переставлены местами</strong></p>
<p>Лексические ошибки – неправильное написание слов. Положительный пример: система WORD (подчеркивание красным).</p>
<p>Лексические ошибки: четыре наиболее распространенные:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; неправильная буква в слове;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; отсутствует одна буква;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; одна лишняя буква;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; две рядом стоящие буквы переставлены в тексте.</p>
<p>Возможность их исправления в автоматизированном режиме</p>
<p><strong>41.Из скольких частей состоит лексема?</strong></p>
<p>Лексема – последовательность допустимых символов ЯП, имеющая смысл для транслятора.</p>
<p>Существует 5 видов лексем:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; идентификаторы (имена, служат для того чтобы обращаться к программным объектам и различать их); Пример: hacker, Hacker и hAcKeR&nbsp; – 3 разных имени;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ключевые слова (зарезервированные идентификаторы, которые имеют специальное значение для компилятора); Пример: if, new, break, float)</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; знаки операций (один или более символов, определяющих действие над операндами); Пример: +, -, ==, != , &lt;=, &gt;=,&nbsp; +=</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; разделители; Примеры разделителей: скобки, точка, запятая.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; константы (литералы, неизменяемые величины). Пример: true, false, null</p>
<p><strong>42.Два основных свойства лексем.</strong></p>
<p>2 правила лексемы: одинаковая длина и однородная цифровая информация.</p>
<p>Лексема может, например, состоять из двух байтов.</p>
<p>Первая часть лексемы показывает «Тип» данной части текста, например: 1 – служебное слово; 2 – целое число 3 – специальный символ и т.д. Во второй части лексемы «Содержание», например, если это служебное слово, то 1 – "Begin", 2 – "End" и т.п.</p>
<p>Таким образом, любую информацию удается привести к единой форме (кстати, цифровой), а также все полученные элементы (лексемы) имеют одинаковую длину.</p>
<p><strong>43.На вход лексического анализатора поступают:</strong></p>
<p>На входе лексического анализатора – текст на входном языке</p>
<p><strong>44.На выходе лексического анализатора получаем:</strong></p>
<p>На выходе – набор лексем(последовательность допустимых символов).</p>
<p><strong>45.Лексический анализатор</strong></p>
<p>Лексический анализатор - процесс аналитического разбора входной последовательности символов с целью получения на выходе другой последовательности символов (например, перевод сторки в число). При этом, группа символов входной последовательности, идентифицируемая на выходе процесса как последовательность допустимых символов (лексема), то есть в процессе лексического анализа производится распознавание и выделение лексем из входной последовательности символов.</p>
<p>На входе – тексты на входном языке. На выходе – лексем (последовательность допустимых символов). Анализирующая часть – поиск ошибок. Генерирующая часть – создание лексем.</p>
<p><strong>46.На вход синтаксического анализатора поступают:</strong></p>
<p>На входе синтаксического анализатора – лексемы</p>
<p><strong>47.На выходе синтаксического анализатора получаем:</strong></p>
<p>На выходе – набор промежуточных таблиц.</p>
<p><strong>48.Вход и выход синтаксического анализатора:</strong></p>
<p>На входе – лексемы.</p>
<p>На выходе – промежуточные таблицы.</p>
<p>Анализирующая часть – поиск ошибок.</p>
<p>Генерирующая часть – формирование текстов на выходном языке</p>
<p><strong>49.Синтаксический анализатор</strong></p>
<p>Синтаксический анализатор — это программа или часть программы, выполняющая синтаксический анализ. В ходе синтаксического анализа исходный текст преобразуется в структуру данных, обычно — в дерево, которое отражает синтаксическую структуру входной последовательности и хорошо подходит для дальнейшей обработки. Как правило, результатом синтаксического анализа является синтаксическое строение предложения, представленное либо в виде дерева</p>
<p><strong>50.Синтаксические ошибки.</strong></p>
<p>Синтаксические ошибки – ошибки в конструкциях используемого ЯП. Т.е., входной текст не соответствует правилам написания входного языка.</p>
<p><strong>51.Что такое синтаксически-управляемый перевод?</strong></p>
<p>Синтаксический управляемый перевод – соответствие между записью в БНФ (Форма Бэкуса — Наура) и ее графическим отображением.</p>
<p>Пример:</p>
<p>Язык = "Начало" Множества Операторы "Конец"</p>
<p>Множества = Множ ";" . . . Множ.</p>
<p>Операторы = Опер . . . Опер</p>
<p><img src="images/51kor.png" class="img-fluid"></p>
<p><strong>52.Какой вариант рекурсии запрещен при применении метода рекурсивного спуска?</strong></p>
<p>Скорее всего ответ – <strong>Многопрограммность</strong> – количество проходов по входному тексту. 1) Иду по входной строке, на выходе сразу же формирую выходную строку.2) Иду по входной строке – формирую лексемы, выбрасывая комментарии, или для начала выброшу комментарии, затем сформирую лексемы.</p>
<p>Метод рекурсивного спуска (вариант появления новых ветвей в дереве разбора)</p>
<p>Рекурсия — это такой способ организации вспомогательного алгоритма (подпрограммы), при котором эта подпрограмма (процедура или функция) в ходе выполнения ее операторов обращается сама к себе.</p>
<p><strong>53.Какой из распознавателей (восходящий, нисходящий) чаще используется?</strong></p>
<p>Нисходящие распознаватели более логичны. Распознаватели – распознает поток информации. Нисходящие распознаватели – сверху вниз по дереву разбора. Восходящие распознаватели – снизу вверх по дереву разбора.</p>
<p><strong>54.Нисходящий распознаватель осуществляет:</strong></p>
<p>Нисходящие распознаватели – сверху вниз по дереву разбора. Нисходящие распознаватели обрабатывают правила сверху вниз, верхние правила раньше нижних</p>
<p><strong>55.Восходящий распознаватель осуществляет:</strong></p>
<p>Восходящие распознаватели – снизу вверх по дереву разбора. Восходящие анализаторы используют нижние правила раньше тех, что расположены выше.</p>
<p><strong>56.Синтаксически-управляемый перевод</strong></p>
<p>См. Пункт 51</p>
<p><strong>57.Что означает словосочетание "слева - направо"?</strong></p>
<p>Название LL произошло от слова Left, поскольку анализатор просматривает входную цепочку слева-направо, и слова Leftmost, поскольку он обнаруживает появление правила по одному или группе символов, образующих левый край цепочки. На практике наибольшее применение имеет класс LL(1) грамматик, для которых детерминированный распознаватель работает по одному входному символу, расположенному в текущей позиции.</p>
<p><strong>58.Что означает словосочетание "сверху-вниз"?</strong></p>
<p>Нисходящие распознаватели обрабатывают правила сверху вниз, верхние правила раньше нижних.</p>
<p><strong>59.Что означает словосочетание "снизу-вверх"?</strong></p>
<p>Восходящие анализаторы используют нижние правила раньше тех, что расположены выше.</p>
<p>Автомат, выполняющий операцию свертки, в отличие от нисходящего распознавателя, не строит в магазине вывод цепочки, начиная с аксиомы грамматики, который соответствует построению синтаксического дерева цепочки “сверху - вниз”, а выполняет сворачивание символов, записанных в магазин. Такой порядок сворачивания символов, записанных в магазин, соответствует правому выводу цепочки, выполняемому “снизу - вверх”. Это обстоятельство объясняет, почему такие распознаватели называются восходящими. Подобный распознаватель должен учитывать при переходе не один символ, расположенный в вершине магазина, а цепочку символов.</p>
<p><strong>60-65. Последовательность (приоритет) выполнения операций арифметического выражения, включающего в себя…</strong></p>
<p>ПОЛНАЯ последовательность выполнения арифметических операций:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Скобки;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Функции;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Логические операции (сначала "НЕ", затем "И" и "ИЛИ");</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Степенные операции;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Мультипликативные операции (*, /);</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Аддитивные операции (+, -).</p>
<p><strong>66. Реализация вложенных скобок осуществляется с помощью</strong></p>
<p>Оператор = Переменная "=" Правая часть.</p>
<p>Правая часть = &lt;/ "-" /&gt; Блок Зн1... Блок</p>
<p>Зн1 = «+» ! «-»</p>
<p>…</p>
<p>Элемент = Цел ! Вещ ! "(" Правая часть ")"</p>
<p>С помощью "(" Правая часть ")" можно осуществлять вложенность скобок с любой глубиной</p>
<p><strong>67. Реализация скобок с ограниченной вложенностью описывается</strong></p>
<p>Оператор = Переменная "=" Правая часть.</p>
<p>Правая часть = &lt;/ "-" /&gt; Блок Зн1... Блок</p>
<p>Зн1 = «+» ! «-»</p>
<p>…</p>
<p>Элемент = Цел ! Вещ ! "(" Правая часть ")"</p>
<p>С помощью "(" Правая часть ")" k&lt;=4 можно осуществлять вложенность скобок с глубиной 4</p>
<p><strong>68. Метод рекурсивного спуска</strong></p>
<p>Метод рекурсивного спуска (метод синтаксических подпрограмм) основан на том, что структура алгоритма часто повторяет структуру читаемых им данных. Повторяющемуся фрагменту данных в алгоритме соответствует цикл, а вариантам представления информации – ветвление.</p>
<p>В методе рекурсивного спуска транслятор или другая программа анализа текста представляется в виде набора подпрограмм, каждая из которых читает и обрабатывает в тексте свою конструкцию и вызывает (в том числе рекурсивно) соответствующие подпрограммы для анализа вложенных в нее конструкций.</p>
<p>Грамматика примет вид:</p>
<p>выражение ::= слагаемое [{+ | -} слагаемое] …</p>
<p>слагаемое ::= число</p>
<p>число ::= цифра …</p>
<p>цифра ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</p>
<p><strong>69. Использование готового программного обеспечения из фондов алгоритмов и программ</strong></p>
<p>Применявшиеся во 2-й половине ХХ века универсальные ЯП:</p>
<p>а) ALGOL 60 (Algorithmic Language). Один из первых универсальных ЯП высокого уровня. Разработан в 1958 – 1960 гг. Оказал значительное влияние на все разработанные впоследствии ЯП высокого уровня.</p>
<p>б) FORTRAN (Formula Translator). Получил широкое практическое применение. Создан с 1954 по 1957 год. ПО на этом языке доступно в исходных кодах, хорошо документировано, отлажено и весьма эффективно.</p>
<p>в) PL/1 (Program Language No 1). Язык включал с себя "алгольную структуру", вычислительные способности FORTRANа и обработку текстовой информации языка COBOL. Язык совмещен из нескольких частей, а не создан по единой концепции. Язык получился большой и малоуправляемый.</p>
<p><strong>70. Совместное программирование, использование программного обеспечения своих коллег</strong></p>
<p>Шаги к совместному программированию:</p>
<p>а) Выбор единого интерфейса. Переход на единое ПО, в которых отдельные модули принадлежат разным исполнителям.</p>
<p>б) Использование одинаковых переменных и меток. Переход на программирование "макрокомандами" (набор операторов, который используется постоянно для решения похожих задач) каждого из партнеров. Формирования каждым партнером своего набора макрокоманд. Сравнение наборов и формирование единого набора макрокоманд для партнеров, работающих совместно.</p>
<p><strong>71. Принципы построения перекодировщиков</strong></p>
<p>Перекодировщик – транслятор без анализирующей части, у него только генерирующая часть.</p>
<p><img src="images/71kor.png" class="img-fluid"></p>
<p>При реализации перекодировщика можно перейти от исходного языка к графическому представлению, и от графического представления уже к другому языку.</p>
<p><strong>72. Б/с программы, как связующее звено между текстами на различных языках программирования</strong></p>
<p>Хз, что тут говорить, в лекциях ничего. Скорее всего надо сказать, что напротив с каждым элементом б/с должны быть соответствующие строчки кода. По аналогии как делали домашку</p>
<p><strong>73. Перевод: Паскаль – Си</strong></p>
<p>1)&nbsp;&nbsp;&nbsp; Совмещение блоков программы на Паскале с элементами графического представления.</p>
<p>2)&nbsp;&nbsp;&nbsp; Максимальное сохранение смысловой составляющей в программе (переменные, метки и т.п.).</p>
<p>3)&nbsp;&nbsp;&nbsp; Построение по элементам графического представления соответствующих блоков на языке Си.</p>
<p>Построение графического описания дает возможность проще понять общую структуру программы и уже на ее основе строить текст на другом ЯП. После получения блок-схемы по ней строится программа на языке Си. Сначала: переводятся основные конструкции: заголовок, циклическая операция, ветвление. Далее переход к реализации менее значимых операций.</p>
<p>Предлагается XML-шаблон для перевода конструкций цикла (с предусловием и постусловием) на языке Паскаль:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; в вариант графического представления;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; в вариант на языке Си.</p>
<p><strong>74. Перевод: Си – Паскаль</strong></p>
<p>1)&nbsp;&nbsp;&nbsp; Совмещение блоков программы на Си с элементами графического представления.</p>
<p>2)&nbsp;&nbsp;&nbsp; Максимальное сохранение смысловой составляющей в программе (переменные, метки и т.п.).</p>
<p>3)&nbsp;&nbsp;&nbsp; Построение по элементам графического представления соответствующих блоков на языке Паскаль.</p>
<p>Построение графического описания дает возможность проще понять общую структуру программы и уже на ее основе строить текст на другом ЯП. После получения блок-схемы по ней строится программа на языке Паскаль. Сначала: переводятся основные конструкции: заголовок, циклическая операция, ветвление. Далее переход к реализации менее значимых операций.</p>
<p>Предлагается XML-шаблон для перевода конструкций цикла (с предусловием и постусловием) на языке Си:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; в вариант графического представления;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; в вариант на языке Паскаль.</p>
<p><strong>75. Конечные автоматы</strong></p>
<p>Конечные автоматы&nbsp;– <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C" title="Модель">модель</a>&nbsp;<a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%BE%D0%B5_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE" title="Дискретное устройство">дискретного устройства</a>, имеющего один вход, один выход и в каждый момент времени находящегося в одном&nbsp;<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5" title="Состояние">состоянии</a>&nbsp;из множества возможных. Можно представить в виде графа или таблицы.</p>
<p>Граф переходов — графическое представление множества состояний и функции переходов. Представляет собой размеченный ориентированный граф, вершины которого — состояния конечного автомата, дуги — переходы из одного состояния в другое, а метки дуг — символы, по которым осуществляется переход из одного состояния в другое. Если переход из состояния q1 в q2 может быть осуществлен по одному из нескольких символов, то все они должны быть надписаны над дугой диаграммы.</p>
<p>Таблица переходов — табличное представление. Обычно в такой таблице каждой строке соответствует одно состояние, а столбцу — один допустимый входной символ. В ячейке на пересечении строки и столбца записывается состояние, в которое должен перейти автомат, если в данном состоянии он считал данный входной символ.</p>
<p>По характеру отсчёта дискретного времени автоматы делятся на синхронные и асинхронные. В синхронных моменты времени, в которые автомат считывает входные сигналы, определяются принудительно синхронизирующими сигналами. Асинхронный считывает входной сигнал непрерывно.</p>
<p><strong>76. Автомат Мура, текстовое представление</strong></p>
<p>Конечный автомат, выходное значение сигнала в котором зависит лишь от текущего состояния данного автомата, и не зависит напрямую, в отличие от автомата Мили, от входных значений.</p>
<p>Может быть определён как кортеж из 6 элементов:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; множество внутренних состояний S (внутренний алфавит);</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; начальное состояние s0;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; множество входных сигналов X (входной алфавит);</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; множество выходных сигналов Y (выходной алфавит);</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; функция переходов Ф : S x X → S;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; функция вывода G : S → Y.</p>
<p><strong>77. Автомат Мура, представление в виде графа</strong></p>
<p><img src="images/77kor.png" class="img-fluid"></p>
<p><strong>78. Автомат Мили, текстовое представление</strong></p>
<p>Конечный автомат, выходная последовательность которого (в отличие от автомата Мура) зависит от состояния автомата и входных сигналов. Это означает, что в графе состояний каждому ребру соответствует некоторое значение (выходной символ). В вершины графа автомата Мили записываются выходящие сигналы, а дугам графа приписывают условие перехода из одного состояния в другое, а также входящие сигналы.</p>
<p>Автомат Мура – совокупность A = (S , X , Y , δ , λ , S<sub>0</sub>), где</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S – конечное непустое множество состояний автомата;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Х – конечное непустое множество входных символов;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y – конечное непустое множество выходных символов;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; δ : S x X → S – функция переходов, отображающих пары состояние / входной символ на соответствующее следующее состояние;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; λ : S x X → Y – функция выходов, отображающая пары состояние / входной символ на соответствующий выходной символ;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S0 ϵ S – начальное состояние.</p>
<p><strong>79. Автомат Мили, представление в виде графа.</strong></p>
<p><img src="images/79kor.png" class="img-fluid"></p>
<p><strong>80. Отладка адаптируемого программного обеспечения</strong></p>
<p>Отладка – этап разработки ПО, на котором обнаруживают, локализуют и устраняют ошибки. Итеративный процесс обнаружения и исправления ошибок, обычно состоящий из 4 этапов: выявление ошибки, локализация ошибки в тексте программы, установление причины ошибки, исправления ошибки.</p>
<p>Использование в полной мере принципа "промежуточной печати". Установка вывода промежуточной печати как в результирующей программе, так и в исходной программе. Сравнение результатов на каждом этапе работы программы.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; после математических вычислений (проверка значений всех переменных).</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; пометка ветвей операторов условного перехода (по какой ветке пошло вычисление.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; сообщение о каждой пройденной итерации цикла.</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; распечатка всех переменных, передаваемых в подпрограмму (функцию).</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; распечатка всех переменных, поступивших в подпрограмму (функцию);</p>
<p><strong>81. Тестирование адаптируемого программного обеспечения</strong></p>
<p>Тестирование ПО – процесс исследования, испытания создаваемого ПО, имеющий своей целью проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе тестов.</p>
<p><strong>82. CASE- технологии</strong></p>
<p>CASE-технология представляет собой методологию проектирования ИС, а также набор инструментальных средств, позволяющих в наглядной форме моделировать предметную область.</p>
<p>CASE-технология включает в себя оригинальный вариант графического представления информации.</p>
<p>Каждая техническая операция (по центру) имеет следующую структуру:</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Слева (основные): исходные данные в стандартном представлении (документы, рабочие материалы, результаты предыдущей операции);</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Сверху (вспомогательные): методические материалы, инструкции, нормативы, и стандарты, критерии оценки результатов;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Снизу (вспомогательные): сведения об исполнителях, программных и технических средствах;</p>
<p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Справа (выходная информация): результаты в стандартном представлении.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>